单件模式，首先构造方法得是私有的，只有单件类内部的代码才可以调用这个构造器。
我们用一个静态方法getInstance来调用私有构造器

Singleton1版本会有多线程安全问题---原子性

Singleton2版本直接使用synchronized解决，但是如果系统高频调用getInstance的话效率就慢了，
可以在调用频率不高的时候使用

Singleton3版本使用饿加载，如果这个单例初始化所需要的资源比较多、时间比较久，这样就不建议，
可以在耗费的资源比较少、时间比较短的时候使用

Singleton4版本使用双重检查加锁，这思路源自于 Singleton1版本 我们只需要在进入第一个if语句块
了之后才需要去加锁，而不是在加入方法的时候就加锁。这样一来只会在一开始加锁，后面都不会加锁了
需要加锁，而且需要加volatile保证可见性。因为即便是单处理器在运行多线程，线程也可能从处理器缓存的
不同地方get到了属于自己的数据。如果不保证有序性，那么当同步块结束以后，单例在另一个线程看来可能还是
没有赋值的。所以需要使用volatile来保证可见性。保持主存和缓存数据的一致性。

还可以使用枚举...


