# 对象与类

## 概述

### 类

类是模板，对象是类的实例。

注意封装（对外隐藏数据）：只有自己类才可以访问里面的字段，别的类不行。对象中的数据称为实例字段，对实例字段进行操作的过程称为方法

每个对象的各个实例字段的集合称为对象的状态

类是可以继承的

### 对象

- 对象的三个特性：1. 行为	2.状态	3. 标识

对象状态的改变必须通过调用方法。（反之则破坏了封装）

每个对象的标识都是不同的，就像身份证

对象的状态反过来会影响它的行为

对象中的数据称为实例字段

### 识别类

认准名词和动词（经验）

### 类之间的关系

1. 依赖（use）：一个类A使用另一个类的对象B，则称A依赖于B。设计原则：尽量减少类之间的依赖关系，耦合
2. 聚合（has）:   一个类A包含另一个类B的对象。
3. 继承（is）：特殊和一般的关系。特殊包含了一般，还多了一些额外的信息。

## 使用预定义类

### 对象与对象变量

声明、初始化

构造器与类名相同，使用时前面要加上new操作符。new 构造器创建了一个对象，没有返回值

对象变量只是引用，并不是包含

Date类用new来构造，表示现在的时间点。localDate类用静态工厂方法来构造，是日历表示法

### 更改器与访问器方法

只访问对象而不修改对象的方法称为访问器方法（状态）

## 用户自定义类

类名，字段、构造器、方法

方法public表示：任何类的任何方法都可以调用这些方法

字段private表示：只有自身类的方法才可以访问

类包含的字段可以是另一个类的对象，聚合

### 构造器

构造器与类名同名，总是结合new操作符使用

特点：1. 同名-new	2. 一个类可以有一个以上的构造器	3. 一个构造器可以有0-n个参数	4. 构造器没有返回值

### var

从变量的初始值可以推断类型，可以使用var来声明且只能方法中**局部变量**

### null

没有引用任何对象

对null的变量调用方法可能会引发严重的错误。

定义类的时候看准那些字段可能为null（对象实例）

解决，if语句，如果为null，设置为一个别的“unknown”

或者调用requireNonNull（n，“xxx”）方法，不为null返回n，否则报错xxx

### 隐式和显式参数

隐式参数：调用方法的对象

显示参数：括号后的数值

在每个方法中this表示隐式参数（即对象）

在方法中多写this可以把局部变量和实例字段区分开

### 封装的优点

若类的实例字段不设置为private则代表，别的类可以肆意更改，这样出错的根源就不易查询

获得和设置实例的值：1. 把数据字段标记为private	2. 有一个public的实例字段的访问器方法和修改器方法。

- 不要编写返回可变对象引用的访问器方法，这样一来在别的类中的实例字段与其是同一个引用，破坏了封装。如果确实需要返回对象的引用，要对它进行克隆，把对象副本放在别的位置。

### 类的访问权限

类的数据字段所标记的private是针对类而言的，即一个方法可以访问**所属**类的**所有**对象的私有数据。

### 私有方法

只要方法为私有就不会再别处被使用，可以删去

## 静态字段与静态方法

### 静态变量

也称为类字段，即它属于类。每个对象都可以对其进行修改，且值共享。

### 静态常量

它属于类，但是不能修改了。加了final关键词

### 静态方法

没有隐式参数，是类方法，可以通过类名直接调用。对象也可以调用但是不推荐

**静态方法可以访问静态字段，但是不能访问实例字段**

下面两种情况使用静态方法：1. 方法不需要访问对象的状态，所需的参数由显示参数提供	2. 方法只需要访问类的静态字段

### 工厂方法

初始化对象除了用构造器，还可以用静态的工厂方法。

使用静态工厂方法的原因有：1. 想要通过不同的名字来初始化不同的对象，构造器只能与类名相同不符合要求。2. 静态工厂方法可以返回子类，构造器只能初始化成同类。

### main方法

main方法是一个入口，执行并构造程序需要的对象

每一个类都可以有main方法用来测试用，但是程序在运行的时候并不会去执行。

## 方法参数

按值调用，方法得到是参数值的一个副本，无法修改参数本体

按引用调用，方法得到的是参数值的地址，可以修改参数本体

Java语言总是按值调用！

因为Java是按值调用，所以Java中基本数据类型（数字布尔）是无法改变的，你能得到的永远只是他们的副本，这没有用；但是对象引用是可以改变对象参数状态的，你可以得到对象引用的副本，副本和本体引用同一个对象，可以通过副本对本体的状态进行修改！所以实现改变对象状态的方法是可行的。

总结Java对方法参数能做什么和不能做什么：1. 方法不能修改基本数据类型的参数	2. 方法可以改变对象参数的状态	3. 方法不能让对象变量引用另一个新的对象（如交换两个对象）

## 对象构造

### 重载

重载构造器方法。通过判断传入参数的类型和个数来决定使用哪个构造器方法

方法的签名：指定方法名和参数类型。

重载返回的类型一定要是一样的

### 默认字段初始化

字段如果在构造器之后都没有初始化，那么会被自动复制为默认值，0，false，null。而局部变量必须在声明的时候就初始化，否则报错。这是字段和局部变量的区别。

### 无参数的构造器

用无参数构造器创建对象时，对象的状态会被设置成适当的默认值。当写一个类时没有提供构造器，那么系统会提供一个无参数的构造器方法，所有的实例字段会设为默认值，0，false，null。如果你写了构造器方法，那么系统就不会提供给你无参数的构造器方法。即如果你写了一个有参数的构造器，那么你就不能再用无参数的构造器创建对象，会报错

- 仅当类没有构造器的时候，系统才会给你一个默认的无参数的构造器。如果自己写了一个有参数的构造器，自己又想使用无参数的构造器，只能自己写一个无参数的构造器

### 显示字段初始化

在声明实例字段的时候可以考虑是否赋值（Java允许，c++不行。c++全部都在构造器中赋值），如果一个类的所有构造器都把某一个实例字段设为同一个值，那么在声明这个实例字段的时候就可以先赋值。

赋值的时候不一定是常量值赋值，也可以是方法赋值，方法得是静态的

### 参数名

在参数前面加上a。aName

参数变量会遮蔽同名的实例字段，故如果参数前面不加a，要实现和前面一样的效果，运用this关键词即可

### 调用另一个构造器

运用this语句可以在构造器中调用另一个构造器，可以避免重复书写代码。this后面加括号带参数

### 初始化块

初始化块在构造器之前执行，一对大括号。

调用构造器的处理步骤：复合构造器第一，为实例字段设置默认值为第二，执行初始化块和初始化方法第三，执行构造器的主体方法最后

初始化方法指的是利用方法赋值，方法是静态的

类第一次加载的时候会进行静态字段的初始化。这时候还没用到构造器，构造器是在创建对象的时候用的。此时只有初始化块和初始化方法

静态字段最先进行初始化，静态方法和静态初始化块按照类声明时候的顺序执行和他们写在哪没有太大关系

接着才是实例字段的初始化按照构造器的步骤来

## 包

### 包名

为了保证包名的唯一性，使用英特网的域名倒序来命名

嵌套的包之间没有任何关系，它们是独立的

访问另一个包的类的方法：1. 写出类的全名，包名+类名	2. import包名+类名

注意使用*只能导入一个包

### 静态导入

这种语句允许导入静态方法和静态字段例如	import java.lang.System.out	import java.lang.System.*

前者只导入了静态字段out，后者把System类中的所有静态方法和静态字段全部导入了

### 在包中增加类

在源文件的开头用package关键词

没有在源文件前放置package语句，默认在无名包中。

编译器不检查目录结构，但是JVM找不到就无法运行。JVM看到package之后会去package中找类。

没有指定访问权限默认是friendly，可以被同包的所有方法访问

作为类的时候是合理的，但是作为字段就不合理了，会破坏封装

### 类路径

类储存在文件系统的子目录中。类的路径必须和包名匹配。否则类加载器找不到！

为了使类能够被多个程序共享应该做到以下几点：

1. 把类文件放在一个目录中
2. jar文件也放在一个目录中
3. 设置类路径。类路径是所有包含类文件的路径的集合

注意：设置类路径时，别忘了包含当前目录，用.表示

编译器总是会在当前目录中查找文件，但是JVM只有在类路径中包含当前目录时才在当前目录中查找

虚拟机要找类文件，先找Java API类，没有才是类路径找

编译器会查看import，然后查看import中和当前包中是否有类，会在类路径在查找个各类

只可以从其他包中导入公共类，但是也也可以从当前包中导入非公共类，查找任务编译器会完成

### 设置类路径

java -cp xxxxxx

## 类设计技巧

1. 保证数据私有，不要破坏封装性
2. 一定要对数据进行初始化。局部变量不初始化会报错，字段会有默认值，但是这两个显然都是不好的
3. 不要在类中使用过多的基本类型。想想是否可以抽象一个类来包含它们
4. 不是所有的字段都需要独立的访问器和修改器。有些字段不需要修改
5. 分解过多职能的类。如果可以明显的把一个复杂的类分解成两个更简单的类，就应该将其分解。
6. 类名和方法名要能体现他们的职能
7. 优先使用不可变的类。即调用方法不会修改本体。











