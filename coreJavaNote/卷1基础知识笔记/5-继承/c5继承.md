# 继承

## 类、子类、超类

### 覆盖方法

不能访问超类的私有字段，只能通过调用超类的方法来访问超类的私有字段，在调用的时候防止调用自己，用super关键词。

super与this的辨析：super不是一个对象的引用，它只是一个调用超类构造器或者方法的一个关键词。

this有两个含义：一个是对隐式参数的引用；二是调用该类的其他构造器

super也有两个含义：一是调用超类的方法；二是调用超类的构造器

### 子类构造器

一般来说子类都要用super来调用超类的构造器，方便初始化超类的私有字段。如果没有调用超类的构造器就会默认调用超类的无参数构造器，如果超类中没有无参数的构造器，就会报错

### 继承层次

由一个超类派生出来的所有类的集合称为继承层次。

从某个特定的类到祖宗类的路径称为继承链。

### 多态

一个对象变量既可以指示多种实际类型的现象称为多态

在**运行时**可以自动选择合适的方法称为动态绑定

is-a规则的另一个表述是替换原则——程序中出现超类的任何地方都可以用子类替换

- 超类对象变量引用子类时，不能调用子类特有的方法，编译器只认为它是超类

### 理解方法的调用（动态绑定）

调用过程：

1. 编译器查看对象的声明类型C和方法名f。列举C类中所有名为f的方法和C的超类中的所有名为f且可以访问的方法（私有方法不可访问）

2. 确定方法调用中的参数类型，如果在所有名为f的方法中只有一个符合的那么就调用这个方法。这个过程称为重载解析。

3. 如果是private方法、static方法、final方法或者构造器那么编译器就将准确的知道应该调用那个方法（运行前就确定）。

   - 解释：如果是private方法，那么这个方法必定不可能从超类得来，只能从C类中调用

     如果是static方法，如果超类和C类都有名为f的static方法，那么只调用C类的f方法，只和声明时的类有关（即只与 Class xxx中的C有关而与xxx无关，这就是与第四点的区别）。如果只有超类有那么就调用超类的，只有C类有就调用C类的，后面这两种在1步骤就已经确定。

     如果是final方法，超类和C类中的f方法一样，没有区别直接调用即可

4. 与之对应的，不依赖于声明时的类型只依赖于隐式参数的实际类型，则必须在**运行时**使用动态绑定。编译器会生成一个利用动态绑定的指令。

   程序在采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。如果实际类型是D，D是C的子类，D中定义了f方法，那么就引用这个方法。否则就在D的超类中寻找这个方法，例如C中。

   如果每次都这样寻找，开销太大了，为了方便动态绑定，虚拟机预先为每个类计算了一个方法表，列出了所以方法的签名和要调用的实际方法。今后每个实际类型直接查找这个表即可。

- 在覆盖一个方法的时候，子类的可见性不能低于超类方法。例如超类的方法为public，则子类的方法也必须为public。

- 理解：第一步找到子类和父类中名为f且可以访问的方法，既找到了所有的候选方法

  第二步查看候选方法中与提供的参数类型匹配的方法。如果只有一个那么就选那个。此时知道方法名和参数类型

  第三部查看是否可以静态绑定，既看看是否能仅通过声明类型来确定要调用的方法。此时的方法访问权限应该为private、static、final。这样就确定调用的是声明类的方法，而不需要去确定实际类型

  第四步采用动态绑定，需要查看实际类型，然后从实际类型往超类查询

### final

不允许拓展的类称为final类，即不允许派生它的子类。方法自动为final

不能覆盖的方法称为final方法

### 强制类型转换

一句话：真的有才能转

用instanceof查看是否能成功

只有要使用特有的方法的时候才使用强制类型转换。一般情况下尽量少用强制类型转换和instanceof运算符

### 抽象类

提供更高层次的抽象，把公共部分放在更高的一层。

可以在高层次的类中声明一个方法但不给予实现，把这个方法声明为抽象方法。声明了抽象方法的类一定也要声明为抽象类。既声明了抽象方法的类一定是抽象类。

- 有抽象方法的类一定是抽象类，但是抽象类中不一定有抽象方法。

抽象方法充当占位方法的角色，它们在子类方法中实现。拓展抽象类可以有两种选择，一是定义所有的抽象类，那么这个类就不是抽象类了；二是定义部分或者不定义抽象类，那么这个类也必须被声明为抽象类。

**抽象类不能实例化**

抽象类不能引用自己的实例，只能引用子类的实例

- 抽象方法解决了另一个问题，减少了强制类型转换的使用。即一个抽象类引用了一个子类，而子类中定义了它的抽象方法，那么就可以直接调用那个方法。在前面的一个例子中，声明的类型中如果没有f方法，但是引用了有f方法的子类，那么它也是没有办法调用f方法的，因为编译把它看成是一个超类的引用。

### 受保护的访问

private:本类可访问

public：对外部完全公开

protected:对本包和子类可见

默认：对本包可见

## Object

Java中每个类都扩展了Object

### object类型的变量

作为各种值得一个泛型容器

Java中只有基本类型不是对象

所有的数组类型，不管是对象数组还是基本类型的数组都扩展了object类

### equals方法

Object类中实现的equals方法将确定**引用**是否相等，这是一个默认的行为，很显然。

但是一般来说检测对象的状态才是符合我们的日常生活

现在给出方法实现的思路：先检测两个对象的引用是否一样，若一样则直接返回true；再检测对象的引用是否为null，如果是null返回false；接下来检测两个对象的类是否一样，这里用到了Object类中的getClass方法得到class类型的对象（每一个类都会有一个**唯一的**class类对象，所以这样检测可行）；最后检测类中的种种字段：注意细节——基本类型的变量可以直接用==运算符检测；如果是String类、LocalDate类等，就需要防止它们为null，那么就使用Objects类中的equals（a，b）方法，如果两个参数都不为null，则调用a.equals(b)方法，这里的a默认是String等系统预定义类，才会有equals方法！

在子类定义equals方法时，首先调用超类的equals，最后直接比较子类中的私有字段即可

### 相等测试与继承

前面的equals方法不允许子类和超类相等，但是如果你有自己的相等判断条件可以允许子类和超类相等，那么可以在判断类相等时改用instanceof运算符来判断，这样就允许了子类和超类进入下一轮的比较。而此时超类的equals方法应该定义为final。

由于传入的参数是Object类，所以比较类的字段的时候需要用到强制类型转换。

- 注意在编写equals时要注意是否覆盖了object类的equals方法

### hashCode方法

散列码（hashCode）是由对象导出的一个整型值。

hashCode方法定义在Object类中，所以每个对象都有一个默认的散列码，这个值有对象的地址得出。

*如果重新定义了equals方法，就必须为客户可能插入散列表的对象重新定义hashCode方法*

用Objects类中的方法定义重新定义hashCode方法。单个参数的时候用Object.hashCode，这个方法会先检测null指针，不为null再调用参数的hashCode方法。多个字段则用Object.hash(xxx,xxx,xxx)这个方法会对各个参数调用Object.hashcode方法，再组合这些值

*equals和hashCode的定义必须相容*

### toString方法

Object中有toString方法,返回类名和散列码

绝大多数的类中的toString方法满足格式：类名加方括号中的字段状态

类名通过getClass.getName得到。不要直接将类名编写进println中，这样会影响到子类的调用

子类的toString方法通过super调用超类，再另起一个[]来填入子类的私有字段

- 只要对象与一个字符串用+号连接起来，编译器就会自动调用对象的toString方法，因为只有String和基本类型才能和String直接连

## 泛型数组列表

C语言在编译的时候就要确定数组的大小，也就是在[]内填的不可以是变量，一定得是常量

Java则可以在运行的时候才确定数组的大小，也就是可以在[]中填写变量。

但是这样也还是没有解决在运行时动态改变数组大小的问题。在Java中解决这个问题的方法就是使用另一个类，名为ArrayList。

ArrayList类和数组很像，但是在增加和删除元素时它可以动态更改数组容量，而不需要为此额外编写代码

*ArrayList是一个有类型参数的泛型类*，为了指定数组列表保存的元素对象的类型，需要用一对尖括号将类名保存起来追加到ArrayList的后面。Arraylist<Employee>。

### 声明数组列表

var xxx=new ArrayList<Employee>()

如果尖括号里面没有说明类型，那么会自动创建一个Object类型的数组列表。

### 访问数组列表元素

方便动态改变大小的同时也增加了访问的困难程度。不能直接访问，只能利用方法改变和得到元素

要想一举两得，就创建一个数组来保存列表中的元素。

foreach语句对于数组列表也适用

数组和数组列表的不同：

1. 不必指定数组的大小
2. 可以add任意多的元素
3. 适用size来计数
4. 使用get来访问

### *类型化与原始数组列表的兼容性*

### 对象包装器与自动装箱

基本类型对应的类称为包装器。（数值类型的类派生于公共超类Number）。包装器类是final类

一旦构造了包装器的实例，就不允许改变包装在其中的值

创建一个包装器的数组列表，可以运用自动装箱直接往里面塞。自动装箱：3--->Integer.valueOf(3)

即可以直接add数值，也可以直接赋值给数值变量。

利用自动拆箱可以进行赋值操作。比如一个Integer类型的引用n可以直接用3来赋值（这边体现了3的自动装箱），然后可以n++，这边体现了n的拆箱然后运算，接着再装箱

- 拆箱装箱是编译器的工作

### 参数数量可变的方法

利用省略号表示可以接收任意数量的参数。在一定意义上可以和数组划等号

作为最后一个参数时，两者可以互换

### 枚举类

- 在class之外声明

所有枚举类都是Enum的子类。

public enum SIze={S,M,L},Size是一个类，正好有括号中的三个实例。S后面还可以跟构造器







