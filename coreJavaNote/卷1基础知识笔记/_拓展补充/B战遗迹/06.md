# day6

## 数据类型

- 数据类型有什么用：用来声明变量，根据不同的类型给变量分配不同的内存空间

- 数据类型在Java中分两种

  第一种：基本数据类型

  - 第一类：整数型（byte、short、int、long）无小数
  - 第二类：浮点型（float、double）带小数
  - 第三类：布尔型（boolean）只有两个值：ture、false  占用一个字节
  - 第四类：字符型（char）必须使用单引号括起来   占用两个字节
  - 八小种：byte、short、int、long、float、double、boolean，char

  第二种：引用数据类型

  字符串型String不属于基本数据类型，它属于引用数据类型

  除了基本数据类型之外都是引用数据类型（引用数据类型面向对象时会接触）

- 八种基本数据类型中

  整数型：byte、short、int、long区别：1、2、4、8字节（二的倍数上升）

  浮点型：float、double区别：4、8字节

  区别：占用的空间大小不同

- byte类型的取值范围？

  byte：[-128~127]256个不同的数字。

  最大值是如何计算的？01111111=127	

  怎么快速算出：给他加1发现变成10000000，然后就是128-1

  注意：在计算机中最左边的是符号位，为0时+	为1时-

  

- 补充说明一下补码：

  首先知道一个事实：计算机中要做减法，电路会非常的复杂。所以目标就是要找到一个方法，把减法可以用加法表示出了

  另一个事实：计算机中每一种数据类型都有一定的范围：模。当数值超出这个最大值模时，系统会自动舍去最高一位。

  在计算机中，真值用原码表示方法：0正1负，后面的跟随二进制。在正数加正数的运算中（或者是负数加负数，负数加负数提一个负号出来就可以转化成正数加正数），可以直接原码相加。但是正数加负数就不能表示了，因为计算机不会像人一样识别前面的正负号进行运算。所以我们寻求其他的方法进行计算。

  下面我们通过模这个概念来引入，我们来计算一下时间（时钟上的12时），我们计算9-2。我们这样来思考，这个计算可以直接计算得出7。但是我们也可以这样，9+（12-2）-12，这是一个等价变形。我们发现，我们取2的模也就是（12-2），让它与9相加，最后的结果够减去模，那么我们就能得到我们想要的答案。

  按照如上的阐述，我们可以很自然地想到，我们要计算一个减法，（此时的模按照8位来算，模是2的七次方第一位是正负号，这里先不管）。我们只需要求出后面那个数（这个数是负数，我们不看第一位，只看后七位代表的它的绝对值）的补数即可。因为模是10000000，等于1111111+0000001，那么补数就是1111111+0000001-xxxxxxx，其中1111111-xxxxxxx表现出来的就是1变成0,0变成1,。最后的结果+1就是补数了。我们算出来的补数替换相应的数直接相加。我们这里只考虑七位。一定会溢出一位。这个时候再考虑最高位的运算。因为是正数加负数，所以相加是1，再算上溢出的一位，相加就是2，再次溢出一位（最高位的前面溢出一位）。这一位被舍去，此时最高位就是0，结合前面的七位，就是正的某某数。结论正确！

  上面的情况是默认前数比后数绝对值大的情况，这里来考虑一下前数的绝对值比后数小的情况。我们还是一样的。取补数，与前数相加，但是区别是，这里的值不会溢出，也就是说没法通过前面的方法得到答案。我们重新思考。取补数与前数相加后得到的数（记为A）需要-模才行。也就是说答案就是-（模-A），也就是此时我们取A的补数，然后符号是负号，也就是说最高位为1。因为取补数与前数相加后得到的数不够大，值不会溢出，所以最高位的1是安全的。所以我们可以认为取补数的方法可以完美的符合计算机的加减法！

  所以我们在计算机中，负数的存储方法用补码来存储。此时我们发现，10000000的补码为00000000，这与正的零00000000一样，我们惊喜的发现，鸡肋的负0和正0在使用了补码之后统一了。那么此时我们就用10000000来表示-128，这就比正数的127多了一个。美妙！