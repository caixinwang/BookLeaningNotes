# 接口、lambda表达式与内部类

## 接口

- 如何定义接口：

  在JDK7及以前，接口中只允许声明全局常量和抽象方法

  public **static final** int a：全局常量——定义接口的时候可以省略public static final它是默认的

  public abstract :抽象方法（可以省略public abstract，也是默认的）

  JDK8：新增可以定义静态方法和默认方法

  JDK9：新增私有方法

  不能定义构造器

  实现类如果没有重写全部的抽象方法，那么这个类就是一个抽象类

  接口与接口之间有继承关系，而且可以多继承

  

接口是一种契约，满足了某个接口的类会对应有某些功能。例如实现Comparable接口的类，可以用Array.sort进行排序，方法返回整数

在声明接口时，方法自动是public。但是在定义方法时，要写出public。

接口中不能有实例字段，但是可以有常量；可以包含多个方法；允许方法实现（不常用也不推荐使用，是JDK新新特性）；

提供实例字段和方法实现的任务应该由实现接口的类来完成。

接口可以看成是没有实例字段的抽象类，小区别是接口可以有多个但是抽象类的父类只能有一个

实现接口的两个步骤：1. 用implements关键词 	2. 对接口中的所有方法提供定义

可以为泛型接口提供参数类型，否则要进行强制类型转换

在类实现了comparable接口之后，才可以sort对于的对象数组

- 注意：如果超类和子类的比较是非法的，那么就应该用if语句把不同类的比较视为非法并抛出异常

  如果超类和子类有统一的比较方式，那么应该在超类提供一个final的compare To的方法

### 接口的属性

接口不能实例化，不能new

可以声明一个接口变量，并且这个变量只能引用实现了这个接口的类对象

instanceof运算符可以检测一个类是否实现了某个接口

接口中的字段默认是public static final，公共常量

### 接口与抽象类

一个类可以实现多个接口

### 静态和私有方法

### 默认方法

用default标记一个默认方法

重要运用”接口演化“，为接口方法提供一个默认的方法，这样之前就实现了接口的其它类不会因为没有实现新方法而报错。

### 解决默认方法冲突

超类优先！

如果两个接口中，默认方法至少实现了一个都会报错，一定要解决二义性。只有两个接口都没有提供默认方法的时候才不会报错，此时程序员要实现这个方法，或者不实现

### 接口与回调

回调是一种常见的程序设计模式。可以指定某个特定事件发生的时候应该采取的动作。

例如Timer类和ActionListener接口的配合。实现的原理：自己创建一个类f（这个类负责完成动作，类名可以是动作的名称），这个类完成了上述接口，实现了ActionPerformed方法。再分别创建一个timer对象和f对象，把时间间隔和f对象传入timer对象的参数中。利用Timer的方法就可以开始

### comparator接口

如果一个类实现了Comparable接口，例如String类。如果你想要换一种比较的方式。可以在sort方法参数中添加一个实现了Comparator接口的类对象，这个类的名称应该取为某可以反映意义的名称。实现的方法名为compare——双参

### 对象克隆

Object中的clone方法只对同包和子类可见。对于外部类来说，Object只对同类可见。所以只有在子类中才可调用clone方法，即在Employee类中可以调用clone，但是在EmployeeTest类中，不能调用clone对Employee对象进行克隆。

克隆的时候要注意的问题：如果字段中有对象的引用，那么要进行深拷贝。这是一般而言，如果是不可变类，或者是类中没有能够修改状态的风险（类中都是常量；没有修改器方法；没有能够生成它的引用），那么也可以不进行深拷贝。

Object类中的clone方法为protected。

要想clone对象，类需要实现cloneable接口。cloneable接口是少数的标记接口，没有任何的方法。这边的Cloneable接口指示类的设计者了解克隆过程。可以把cloneable接口理解成使用clone方法的门票。但是即使有了门票测试类也不能克隆对象，因为此时使用的clone方法是Object类中的，声明为protected，只有对类才可见。所以一般如果要在外面也能clone，就需要在类中覆盖Object中的clone方法，此时的clone才是public。

- Object中的clone返回Object对象，注意强制类型转换的使用
- 在覆盖clone方法的时候需要声明异常。main方法也需要
- 所有数组类型都有一个公共的clone方法。数组名加clone就能调用

### 小总结

为什么说接口是一种规范，假设现在我们需要实现一个东西叫做“重复器”，我们可以为它定义一个类叫做Repeater，这个类中显然有一个方法叫做repeat，需要一个int参数来告诉这个重复器需要重复几次。但是这就够了吗？我们这个重复器现在还不知道重复些什么，重复一个动作？我们假设我们需要这个重复器重复一个动作（方法名叫做doit），我们把使用repeat之前需要先有一个doit方法的需求叫做一种规范或契约，我们需要一个接口（契约）来确保这个doit方法是存在的，否则我们的repeater就无法正常运行。

## lambda表达式

lambda表达式可以理解成一个函数，它可以转化成一个接口，可以赋值给接口的实例。这个原理在底层上其实是创建了一个实现了接口的对象（实例），然后这个对象实现了该接口，接口的方法体是lambda表达式。

所以如果一个方法需要实现了某接口的对象作为参数，可以将lambda表达式直接填在参数上，在底层会自动形成一个对象传入，避免了繁琐的对象与类的构造。

lambda表达式所能做的只有转化为函数式接口。所谓函数式接口就是只有一个抽象方法的接口。

- 注意lambda表达式其中一个分支有返回值，那么所有的分支都应该返回值，否则报错

lambda表达式无需指定返回值，其返回值会根据上下文自动推出

lambda表达式的参数可以不指定类型，在可以根据语境推出的情况下。例如，Sort方法的第一个参数填了String类型的数组，第二个参数需要一个实现了Comparator<String>接口的对象，所以如果将lambda表达式填在参数位置上，就不需要指明参数的类型，他自动是String类型的

### 方法引用

方法引用其实也可以看成是方法体

方法引用有三种类型：一种是对象加实例方法；另一种是类加实例方法；最后一种是类加静态方法

在底层上也是创建了一个实现了接口的实例，接口的方法体是上面的对象或类的实例方法或者静态方法

第一种类型，不缺隐式参数，所以变量之间传入方法；第二种类型缺少隐式参数，第一个变量传入当做隐式参数，第二个变量传入方法；第三种类型不缺隐式参数，所以和第一种一样两个变量全部传入方法

- 在lambda表达式只调用一个抽象方法而不进行其它操作的时候和方法引用可以互相转化。但是如果lambda表达式进行诸如比较的其他操作则不能转化成方法引用。可见lambda表达式的运用比方法引用更胜一筹
- 方法引用和其等价的lambda表示的细微区别：lambda表达式在运行才null报错，而方法引用在构造的时候就报错了。原因可以猜测：因为方法引用需要有对象，编译器会检查对象是否为null

还有关于super和this的使用

### 构造器引用

和方法引用类似，只是方法名变成了new

### 变量作用域

如果一个lambda表达式用到了外围的局部变量，为了防止局部变量失效，这个lambda表达式变成实例对象之后会把变量拷贝到实例字段中。

- 关于代码块以及自由变量值有一个术语叫做：闭包——lambda表达式就是闭包

  只能捕获值不会改变的自由变量，即不能再内部或者外部对这个变量进行加减等运算。原因是：如果在lambda表达式中改变值，并发执行多个动作就会不安全

- 规则：lambda表达式捕获的变量必须是事实最终变量——指这个变量初始化之后不会再为它赋值
- lambda表达式的体和嵌套块有相同的作用域，所以lambda表达式体里不能声明与外面的相同的变量
- 

